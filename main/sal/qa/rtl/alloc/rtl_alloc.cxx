/**************************************************************
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 *************************************************************/




// MARKER(update_precomp.py): autogen include statement, do not remove
#include "precompiled_sal.hxx"
// autogenerated file with codegen.pl

#include <rtl/alloc.h>
#include "gtest/gtest.h"

namespace rtl_alloc
{

    // small memory check routine, which return false, if there is a problem

    bool checkMemory(char* _pMemory, sal_uInt32 _nSize, char _n)
    {
        bool bOk = true;

        for (sal_uInt32 i=0;i<_nSize;i++)
        {
            if (_pMemory[i] != _n)
            {
                bOk = false;
            }
        }
        return bOk;
    }

class Memory : public ::testing::Test
{
protected:
    // for normal alloc functions
    char       *m_pMemory;
    sal_uInt32  m_nSizeOfMemory;

public:
    Memory()
            :m_pMemory(NULL),
             m_nSizeOfMemory(50 * 1024 * 1024)
    {
    }

    // initialise your test code values here.
    void SetUp()
    {
            printf("allocate memory\n");
            m_pMemory = (char*) rtl_allocateMemory( m_nSizeOfMemory );
    }

    void TearDown()
    {
            printf("free memory\n");
            rtl_freeMemory(m_pMemory);
            m_pMemory = NULL;
    }
}; // class test

TEST_F(Memory, rtl_allocateMemory_001)
{
    ASSERT_TRUE(m_pMemory != NULL) << "Can get zero memory.";
    memset(m_pMemory, 1, m_nSizeOfMemory);
    ASSERT_TRUE(checkMemory(m_pMemory, m_nSizeOfMemory, 1) == true) << "memory contains wrong value.";
}

TEST_F(Memory, rtl_reallocateMemory_001)
{
    printf("reallocate memory\n");
    sal_uInt32 nSize = 10 * 1024 * 1024;
    m_pMemory = (char*)rtl_reallocateMemory(m_pMemory, nSize);

    ASSERT_TRUE(m_pMemory != NULL) << "Can reallocate memory.";
    memset(m_pMemory, 2, nSize);
    ASSERT_TRUE(checkMemory(m_pMemory, nSize, 2) == true) << "memory contains wrong value.";
}

class ZeroMemory : public ::testing::Test
{
protected:
    // for zero functions
    char       *m_pZeroMemory;
    sal_uInt32  m_nSizeOfZeroMemory;

public:
    ZeroMemory()
            :m_pZeroMemory(NULL),
             m_nSizeOfZeroMemory( 50 * 1024 * 1024 )
    {
    }

    // initialise your test code values here.
    void SetUp()
    {
        printf("allocate zero memory\n");
        m_pZeroMemory = (char*) rtl_allocateZeroMemory( m_nSizeOfZeroMemory );
    }

    void TearDown()
    {
        printf("free zero memory\n");
        rtl_freeZeroMemory(m_pZeroMemory, m_nSizeOfZeroMemory);
        // LLA: no check possible, may GPF if there is something wrong.
        // ASSERT_TRUE(pZeroMemory != NULL) << "Can get zero memory.";
    }

}; // class test

TEST_F(ZeroMemory, rtl_allocateZeroMemory_001)
{
    ASSERT_TRUE(m_pZeroMemory != NULL) << "Can get zero memory.";
    ASSERT_TRUE(checkMemory(m_pZeroMemory, m_nSizeOfZeroMemory, 0) == true) << "memory contains wrong value.";

    memset(m_pZeroMemory, 3, m_nSizeOfZeroMemory);
    ASSERT_TRUE(checkMemory(m_pZeroMemory, m_nSizeOfZeroMemory, 3) == true) << "memory contains wrong value.";
}

} // namespace rtl_alloc

int main(int argc, char **argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
